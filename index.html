<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å°è²å°éºµå¤§æˆ°æµæ„Ÿç—…æ¯’ - ç©¶æ¥µçˆ½å¿«ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; font-family: "Microsoft JhengHei", sans-serif; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 15px; left: 15px; right: 15px;
            color: white; pointer-events: none; z-index: 10;
            display: flex; justify-content: space-between; align-items: flex-start;
        }

        .bar-label { font-size: 13px; font-weight: bold; text-shadow: 1px 1px 3px #000; }
        .bar-container { width: 110px; height: 10px; background: rgba(255,255,255,0.2); border: 1px solid #fff; border-radius: 10px; overflow: hidden; margin-top: 3px; }
        #fever-bar { width: 0%; height: 100%; background: linear-gradient(to right, #ffcc00, #ff4400); transition: width 0.2s; }
        #boss-hp-fill { width: 100%; height: 100%; background: #ff0055; transition: width 0.1s; }
        #boss-hp-ui { display: none; text-align: right; }

        #nuke-inventory {
            position: absolute; top: 60px; right: 15px; 
            z-index: 100; display: flex; flex-direction: column; align-items: center;
            pointer-events: auto; cursor: pointer;
        }
        #nuke-btn {
            width: 50px; height: 50px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.15); border: 1.5px solid rgba(255, 215, 0, 0.8);
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        #nuke-btn img { width: 32px; height: 32px; filter: drop-shadow(0 0 2px gold); }
        #nuke-count { color: #fff; font-weight: bold; font-size: 16px; margin-top: 4px; text-shadow: 1px 1px 3px #000; }
        #nuke-effect { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; display: none; z-index: 5; mix-blend-mode: screen; pointer-events: none; }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none; flex-direction: column;
            justify-content: center; align-items: center; color: white; text-align: center; z-index: 200;
        }
        button.restart-btn { padding: 12px 35px; font-size: 18px; background: #2ecc71; border: none; color: white; border-radius: 50px; margin-top: 20px; cursor: pointer; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div>
        <div class="bar-label">ç™¼ç‡’å€¼ (Fever)</div>
        <div class="bar-container"><div id="fever-bar"></div></div>
    </div>
    <div id="boss-hp-ui">
        <div class="bar-label" style="color: #ff0055;">æµæ„Ÿå¤§é­”ç‹</div>
        <div class="bar-container"><div id="boss-hp-fill"></div></div>
    </div>
</div>

<div id="nuke-inventory" onclick="useNuke()">
    <div id="nuke-btn"><img src="tamiflu.png" alt="Nuke"></div>
    <div id="nuke-count">0</div>
</div>

<img id="nuke-effect" src="nuke_fx.gif">

<div id="overlay">
    <h1 id="msg-title"></h1>
    <p id="msg-desc"></p>
    <button class="restart-btn" onclick="resetGame()">å†æˆ°ä¸€æ¬¡</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const nukeImg = document.getElementById('nuke-effect');
const nukeCountDisplay = document.getElementById('nuke-count');

let fever = 0, score = 0, bossHP = 1500, gameState = 'playing', isBossStage = false;
let shakeTime = 0, nukeStock = 0; 

const FEVER_MAX = 100, BOSS_MAX = 1500;
const assets = { hero: 'hero.png', virus: 'virus_small.png', boss: 'boss.png', pill: 'pill.png', syrup: 'syrup.png', tamiflu: 'tamiflu.png', bg: 'bg.jpg' };
const imgs = {};
Object.keys(assets).forEach(k => { 
    imgs[k] = new Image(); 
    imgs[k].src = assets[k];
    // é™¤éŒ¯ç”¨ï¼šå¦‚æœåœ–ç‰‡è¼‰å…¥å¤±æ•—æœƒåœ¨æ§åˆ¶å°é¡¯ç¤º
    imgs[k].onerror = () => console.error("ç„¡æ³•è¼‰å…¥åœ–ç‰‡:", assets[k]);
});

const keys = {};
window.addEventListener('keydown', (e) => { 
    keys[e.key] = true; 
    if(e.key === ' ' || e.code === 'Space') useNuke(); 
});
window.addEventListener('keyup', (e) => { keys[e.key] = false; });

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

class Player {
    constructor() { 
        this.w = 110; this.h = 110; 
        this.x = canvas.width/2 - this.w/2; 
        this.y = canvas.height - 150; 
    }
    draw() { 
        if(imgs.hero.complete) ctx.drawImage(imgs.hero, this.x, this.y, this.w, this.h);
        else { ctx.fillStyle = "lime"; ctx.fillRect(this.x, this.y, this.w, this.h); } // æ²’åœ–æ™‚é¡¯ç¤ºæ–¹å¡Š
    }
}

class Bullet {
    constructor(x, y, isEnemy = false) {
        this.x = x; this.y = y; this.isEnemy = isEnemy;
        this.w = isEnemy ? 12 : 20; this.h = isEnemy ? 12 : 40;
        this.speed = isEnemy ? 5.5 : -18;
    }
    update() { this.y += this.speed; }
    draw() {
        if (this.isEnemy) {
            ctx.fillStyle = "#ff0055";
            ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill();
        } else {
            if(imgs.pill.complete) ctx.drawImage(imgs.pill, this.x - this.w/2, this.y, this.w, this.h);
            else { ctx.fillStyle = "white"; ctx.fillRect(this.x - this.w/2, this.y, 10, 20); }
        }
    }
}

class Enemy {
    constructor(isBoss = false) {
        this.isBoss = isBoss; 
        this.w = isBoss ? 200 : 65; 
        this.h = isBoss ? 200 : 65; 
        this.x = isBoss ? canvas.width/2-100 : Math.random()*(canvas.width-65);
        this.y = -220; 
        this.speed = isBoss ? 0.6 : 3 + Math.random() * 2.5;
        this.dir = 1; this.shootTimer = 0;
    }
    update() {
        this.y += this.speed;
        if (this.isBoss) {
            this.x += this.dir * 2.2;
            if (this.x <= 0 || this.x >= canvas.width - this.w) this.dir *= -1;
            if (this.y > 70) this.y = 70;
            this.shootTimer++;
            if (this.shootTimer > 30) {
                bullets.push(new Bullet(this.x + this.w/2, this.y + this.h, true));
                this.shootTimer = 0;
            }
        }
    }
    draw() { 
        let img = this.isBoss ? imgs.boss : imgs.virus;
        if(img.complete) ctx.drawImage(img, this.x, this.y, this.w, this.h);
        else { ctx.fillStyle = "red"; ctx.fillRect(this.x, this.y, this.w, this.h); }
    }
}

class Item {
    constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.w = 45; this.h = 45; }
    update() { this.y += 3.2; }
    draw() { 
        if(imgs[this.type].complete) ctx.drawImage(imgs[this.type], this.x, this.y, this.w, this.h);
        else { ctx.fillStyle = this.type === 'syrup' ? "orange" : "gold"; ctx.fillRect(this.x, this.y, this.w, this.h); }
    }
}

let player = new Player(), bullets = [], enemies = [], items = [], lastFire = 0;

function handlePointer(e) {
    if (gameState !== 'playing') return;
    const rect = canvas.getBoundingClientRect();
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
    player.x = clientX - rect.left - player.w/2;
    const yOffset = (e.touches) ? 80 : 0;
    player.y = clientY - rect.top - player.h/2 - yOffset;
}

canvas.addEventListener('pointermove', handlePointer);
canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handlePointer(e); }, {passive: false});

function useNuke() {
    if (nukeStock > 0 && gameState === 'playing') {
        nukeStock--;
        updateNukeUI();
        nukeImg.style.display = 'block';
        let s = nukeImg.src; nukeImg.src = ""; nukeImg.src = s;
        shakeTime = 30;
        enemies.forEach(e => { if(!e.isBoss) score++; });
        enemies = enemies.filter(e => e.isBoss);
        if(isBossStage) bossHP -= 300; 
        setTimeout(() => nukeImg.style.display = 'none', 1600);
    }
}

function updateNukeUI() {
    nukeCountDisplay.innerText = nukeStock;
    nukeCountDisplay.style.color = nukeStock > 0 ? "gold" : "white";
}

function update() {
    if (gameState !== 'playing') return;
    
    // éµç›¤ç§»å‹•
    const moveSpeed = 8;
    if (keys['ArrowUp'] || keys['w']) player.y -= moveSpeed;
    if (keys['ArrowDown'] || keys['s']) player.y += moveSpeed;
    if (keys['ArrowLeft'] || keys['a']) player.x -= moveSpeed;
    if (keys['ArrowRight'] || keys['d']) player.x += moveSpeed;
    player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));
    player.y = Math.max(0, Math.min(canvas.height - player.h, player.y));

    if (Date.now() - lastFire > 250) { 
        bullets.push(new Bullet(player.x + player.w/2, player.y)); 
        lastFire = Date.now(); 
    }

    if (score >= 25 && !isBossStage) {
        isBossStage = true; enemies.push(new Enemy(true));
        document.getElementById('boss-hp-ui').style.display = 'block';
    }
    if (!isBossStage && Math.random() < 0.04) enemies.push(new Enemy());

    bullets.forEach((b, bi) => {
        b.update();
        if (b.isEnemy) {
            if (checkCol(b, player)) { fever += 12; bullets.splice(bi, 1); shakeTime = 8; }
        } else {
            enemies.forEach((e, ei) => {
                if (checkCol(b, e)) {
                    if (e.isBoss) {
                        bossHP -= 10;
                        if (Math.random() < 0.06) { // é­”ç‹æ‰å¯¶æ©Ÿç‡æå‡è‡³ 6%
                            let type = Math.random() < 0.5 ? 'syrup' : 'tamiflu';
                            items.push(new Item(e.x + Math.random() * e.w, e.y + e.h/2, type));
                        }
                    } else {
                        // --- æ ¸å¿ƒä¿®æ­£ï¼šæ˜ç¢ºå€åˆ†æ‰è½æ©Ÿç‡ ---
                        let rand = Math.random();
                        if (rand < 0.20) items.push(new Item(e.x, e.y, 'syrup'));   // 20% è—¥æ°´
                        else if (rand < 0.40) items.push(new Item(e.x, e.y, 'tamiflu')); // 20% æ ¸å½ˆ
                        // ç¸½æ‰å¯¶æ©Ÿç‡ 40%
                        
                        enemies.splice(ei, 1); score++;
                    }
                    bullets.splice(bi, 1);
                }
            });
        }
        if (b.y < -50 || b.y > canvas.height + 50) bullets.splice(bi, 1);
    });

    enemies.forEach((e, ei) => {
        e.update();
        if (checkCol(e, player)) {
            fever += e.isBoss ? 2 : 25; 
            if(!e.isBoss) enemies.splice(ei, 1); 
            shakeTime = 12;
        }
        if (e.y > canvas.height + 150) enemies.splice(ei, 1);
    });

    items.forEach((it, ii) => {
        it.update();
        if (checkCol(it, player)) {
            if (it.type === 'syrup') fever = Math.max(0, fever - 35);
            else { nukeStock++; updateNukeUI(); }
            items.splice(ii, 1);
        }
        if (it.y > canvas.height + 100) items.splice(ii, 1);
    });

    document.getElementById('fever-bar').style.width = fever + '%';
    if (isBossStage) document.getElementById('boss-hp-fill').style.width = (bossHP/BOSS_MAX*100) + '%';
    if (fever >= FEVER_MAX) end(false); if (bossHP <= 0) end(true);
}

function checkCol(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

function draw() {
    ctx.save();
    if (shakeTime > 0) { ctx.translate(Math.random()*10-5, Math.random()*10-5); shakeTime--; }
    
    // --- é˜²é»‘å±ï¼šå…ˆç•«åº•è‰²å†ç•«èƒŒæ™¯åœ– ---
    ctx.fillStyle = "#001";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    if (imgs.bg.complete) {
        const scale = Math.max(canvas.width / imgs.bg.width, canvas.height / imgs.bg.height);
        const x = (canvas.width / 2) - (imgs.bg.width / 2) * scale;
        const y = (canvas.height / 2) - (imgs.bg.height / 2) * scale;
        ctx.drawImage(imgs.bg, x, y, imgs.bg.width * scale, imgs.bg.height * scale);
    }

    items.forEach(it => it.draw());
    bullets.forEach(b => b.draw());
    enemies.forEach(e => e.draw());
    player.draw();
    ctx.restore();
    if (gameState === 'playing') requestAnimationFrame(() => { update(); draw(); });
}

function end(win) {
    gameState = win ? 'win' : 'over';
    document.getElementById('overlay').style.display = 'flex';
    document.getElementById('msg-title').innerText = win ? "ğŸ† æ­å–œåº·å¾©ï¼" : "ğŸ’¤ éœ€è¦ä¼‘æ¯äº†...";
    document.getElementById('msg-desc').innerText = win ? "å°è²å°éºµæ“Šæ•—äº†é­”ç‹ï¼Œèº«é«”è®Šå¼·äº†ï¼" : "ç™¼ç‡’å¤ªåš´é‡äº†ï¼Œè¶•å¿«ä¼‘æ¯å–æ°´å§ï¼";
}

function resetGame() {
    fever = 0; score = 0; bossHP = BOSS_MAX; isBossStage = false; gameState = 'playing';
    enemies = []; bullets = []; items = []; nukeStock = 0; updateNukeUI();
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('boss-hp-ui').style.display = 'none';
    draw();
}

// ç›´æ¥å•Ÿå‹•ï¼Œä¸å†ç­‰å¾…èƒŒæ™¯åœ–è¼‰å…¥
draw();
</script>
</body>
</html>
