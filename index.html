<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å°éºµå¤§æˆ°æµæ„Ÿç—…æ¯’ - æ ¸å½ˆä¿®å¾©ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; font-family: sans-serif; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 15px; left: 10px; right: 10px;
            color: white; pointer-events: none; z-index: 10;
            display: flex; justify-content: space-between;
        }

        .bar-container { width: 120px; height: 14px; background: rgba(255,255,255,0.2); border: 1.5px solid #fff; border-radius: 10px; overflow: hidden; margin-top: 5px; }
        #fever-bar { width: 0%; height: 100%; background: linear-gradient(to right, #ffcc00, #ff4400); transition: width 0.2s; }
        #boss-hp-fill { width: 100%; height: 100%; background: #ff0055; transition: width 0.1s; }
        #boss-hp-ui { display: none; text-align: right; }

        /* å³ä¸Šè§’æ ¸å½ˆç´¯ç©å€ */
        #nuke-inventory {
            position: absolute; top: 70px; right: 15px; 
            z-index: 100; display: flex; flex-direction: column; align-items: center;
            pointer-events: auto; /* å¿…é ˆç‚º auto æ‰èƒ½é»æ“Š */
        }
        #nuke-btn {
            width: 75px; height: 75px; border-radius: 50%;
            background: rgba(255, 215, 0, 0.4); border: 3px solid gold;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            transition: transform 0.1s;
        }
        #nuke-btn:active { transform: scale(0.8); }
        #nuke-btn img { width: 50px; height: 50px; }
        #nuke-count {
            color: #fff; font-weight: bold; font-size: 24px; 
            background: rgba(0,0,0,0.5); padding: 2px 10px; border-radius: 10px;
            text-shadow: 2px 2px 4px #000; margin-top: 5px;
        }

        #nuke-effect {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; display: none; z-index: 5; mix-blend-mode: screen;
        }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none; flex-direction: column;
            justify-content: center; align-items: center; color: white; text-align: center; z-index: 200;
        }
        button.restart-btn { padding: 15px 40px; font-size: 20px; background: #2ecc71; border: none; color: white; border-radius: 50px; margin-top: 20px; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div>
        <div style="font-size: 14px; font-weight: bold;">ç™¼ç‡’å€¼ (Fever)</div>
        <div class="bar-container"><div id="fever-bar"></div></div>
    </div>
    <div id="boss-hp-ui">
        <div style="font-size: 14px; font-weight: bold; color: #ff0055;">æµæ„Ÿå¤§é­”ç‹</div>
        <div class="bar-container"><div id="boss-hp-fill"></div></div>
    </div>
</div>

<div id="nuke-inventory" onclick="useNuke()">
    <div id="nuke-btn">
        <img src="tamiflu.png" alt="Nuke">
    </div>
    <div id="nuke-count">x 0</div>
    <div style="color: white; font-size: 12px; font-weight: bold; margin-top:2px;">é»æˆ‘ç™¼å°„</div>
</div>

<img id="nuke-effect" src="nuke_fx.gif">

<div id="overlay">
    <h1 id="msg-title"></h1>
    <p id="msg-desc"></p>
    <button class="restart-btn" onclick="resetGame()">å†æˆ°ä¸€æ¬¡</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const nukeImg = document.getElementById('nuke-effect');
const nukeCountDisplay = document.getElementById('nuke-count');

let fever = 0, score = 0, bossHP = 1200, gameState = 'playing', isBossStage = false;
let shakeTime = 0, nukeStock = 0; 

const FEVER_MAX = 100, BOSS_MAX = 1200;
const assets = { hero: 'hero.png', virus: 'virus_small.png', boss: 'boss.png', pill: 'pill.png', syrup: 'syrup.png', tamiflu: 'tamiflu.png', bg: 'bg.jpg' };
const imgs = {};
Object.keys(assets).forEach(k => { imgs[k] = new Image(); imgs[k].src = assets[k]; });

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

class Player {
    constructor() { this.w = 70; this.h = 70; this.x = canvas.width/2-35; this.y = canvas.height-150; }
    draw() { ctx.drawImage(imgs.hero, this.x, this.y, this.w, this.h); }
}

class Bullet {
    constructor(x, y, isEnemy = false) {
        this.x = x; this.y = y; this.isEnemy = isEnemy;
        this.w = isEnemy ? 15 : 20; this.h = isEnemy ? 15 : 40;
        this.speed = isEnemy ? 6 : -18;
    }
    update() { this.y += this.speed; }
    draw() {
        if (this.isEnemy) {
            ctx.fillStyle = "#ff0055";
            ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI*2); ctx.fill();
        } else {
            ctx.drawImage(imgs.pill, this.x - this.w/2, this.y, this.w, this.h);
        }
    }
}

class Enemy {
    constructor(isBoss = false) {
        this.isBoss = isBoss; 
        this.w = isBoss ? 200 : 70; // ä¿®æ­£å°å…µå¯¬åº¦
        this.h = isBoss ? 200 : 70; 
        this.x = isBoss ? canvas.width/2-100 : Math.random()*(canvas.width-70);
        this.y = -220; 
        this.speed = isBoss ? 0.6 : 3 + Math.random() * 3;
        this.dir = 1; this.shootTimer = 0;
    }
    update() {
        this.y += this.speed;
        if (this.isBoss) {
            this.x += this.dir * 2.5;
            if (this.x <= 0 || this.x >= canvas.width - this.w) this.dir *= -1;
            if (this.y > 60) this.y = 60;
            this.shootTimer++;
            if (this.shootTimer > 30) {
                bullets.push(new Bullet(this.x + this.w/2, this.y + this.h, true));
                this.shootTimer = 0;
            }
        }
    }
    draw() { ctx.drawImage(this.isBoss?imgs.boss:imgs.virus, this.x, this.y, this.w, this.h); }
}

class Item {
    constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.w = 60; this.h = 60; }
    update() { this.y += 3.5; }
    draw() { ctx.drawImage(imgs[this.type], this.x, this.y, this.w, this.h); }
}

let player = new Player(), bullets = [], enemies = [], items = [], lastFire = 0;

canvas.addEventListener('touchmove', (e) => {
    if (gameState !== 'playing') return;
    const t = e.touches[0];
    player.x = t.clientX - player.w/2;
    player.y = t.clientY - player.h - 40;
    e.preventDefault();
}, {passive: false});

function useNuke() {
    if (nukeStock > 0 && gameState === 'playing') {
        nukeStock--;
        updateNukeUI();
        
        nukeImg.style.display = 'block';
        let s = nukeImg.src; nukeImg.src = ""; nukeImg.src = s;
        shakeTime = 30;
        
        enemies.forEach(e => { if(!e.isBoss) score++; });
        enemies = enemies.filter(e => e.isBoss);
        if(isBossStage) bossHP -= 250; 
        
        setTimeout(() => nukeImg.style.display = 'none', 1600);
    }
}

function updateNukeUI() {
    nukeCountDisplay.innerText = "x " + nukeStock;
    nukeCountDisplay.style.transform = "scale(1.3)";
    setTimeout(() => { nukeCountDisplay.style.transform = "scale(1)"; }, 200);
}

function drawBG() {
    if (!imgs.bg.complete) return;
    const scale = Math.max(canvas.width / imgs.bg.width, canvas.height / imgs.bg.height);
    const x = (canvas.width / 2) - (imgs.bg.width / 2) * scale;
    const y = (canvas.height / 2) - (imgs.bg.height / 2) * scale;
    ctx.drawImage(imgs.bg, x, y, imgs.bg.width * scale, imgs.bg.height * scale);
}

function update() {
    if (gameState !== 'playing') return;
    if (Date.now() - lastFire > 250) { 
        bullets.push(new Bullet(player.x + player.w/2, player.y)); 
        lastFire = Date.now(); 
    }

    if (score >= 30 && !isBossStage) {
        isBossStage = true; enemies.push(new Enemy(true));
        document.getElementById('boss-hp-ui').style.display = 'block';
    }
    if (!isBossStage && Math.random() < 0.04) enemies.push(new Enemy());

    bullets.forEach((b, bi) => {
        b.update();
        if (b.isEnemy) {
            if (checkCol(b, player)) { fever += 12; bullets.splice(bi, 1); shakeTime = 8; }
        } else {
            enemies.forEach((e, ei) => {
                if (checkCol(b, e)) {
                    if (e.isBoss) bossHP -= 10; else {
                        let rand = Math.random();
                        // æé«˜æ‰è½ç‡ï¼š15% é€€ç‡’è—¥ï¼Œ25% å…‹æµæ„Ÿ
                        if (rand < 0.15) items.push(new Item(e.x, e.y, 'syrup'));
                        else if (rand < 0.40) items.push(new Item(e.x, e.y, 'tamiflu')); 
                        enemies.splice(ei, 1); score++;
                    }
                    bullets.splice(bi, 1);
                }
            });
        }
        if (b.y < -50 || b.y > canvas.height + 50) bullets.splice(bi, 1);
    });

    enemies.forEach((e, ei) => {
        e.update();
        if (checkCol(e, player)) {
            fever += e.isBoss ? 2 : 25; 
            if(!e.isBoss) enemies.splice(ei, 1); 
            shakeTime = 12;
        }
        if (e.y > canvas.height + 250) enemies.splice(ei, 1);
    });

    items.forEach((it, ii) => {
        it.update();
        if (checkCol(it, player)) {
            if (it.type === 'syrup') {
                fever = Math.max(0, fever - 30);
            } else {
                nukeStock++; 
                updateNukeUI();
            }
            items.splice(ii, 1);
        }
        if (it.y > canvas.height + 100) items.splice(ii, 1);
    });

    document.getElementById('fever-bar').style.width = fever + '%';
    if (isBossStage) document.getElementById('boss-hp-fill').style.width = (bossHP/BOSS_MAX*100) + '%';
    if (fever >= FEVER_MAX) end(false); if (bossHP <= 0) end(true);
}

function checkCol(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

function draw() {
    ctx.save();
    if (shakeTime > 0) { ctx.translate(Math.random()*12-6, Math.random()*12-6); shakeTime--; }
    drawBG();
    items.forEach(it => it.draw());
    bullets.forEach(b => b.draw());
    enemies.forEach(e => e.draw());
    player.draw();
    ctx.restore();
    if (gameState === 'playing') requestAnimationFrame(() => { update(); draw(); });
}

function end(win) {
    gameState = win ? 'win' : 'over';
    document.getElementById('overlay').style.display = 'flex';
    document.getElementById('msg-title').innerText = win ? "ğŸ† æ­å–œç•¢æ¥­ï¼" : "ğŸ’¤ è©²ä¼‘æ¯äº†...";
    document.getElementById('msg-desc').innerText = win ? "å°éºµç”¨ç­–ç•¥æ“Šæ•—äº†é­”ç‹ï¼Œèº«é«”è®Šå¼·äº†ï¼" : "ç™¼ç‡’å€¼å¤ªé«˜äº†ï¼Œè¶•å¿«ä¼‘æ¯å–æ°´å§ï¼";
}

function resetGame() {
    fever = 0; score = 0; bossHP = BOSS_MAX; isBossStage = false; gameState = 'playing';
    enemies = []; bullets = []; items = []; nukeStock = 0; updateNukeUI();
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('boss-hp-ui').style.display = 'none';
    draw();
}

imgs.bg.onload = () => draw();
</script>
</body>
</html>
